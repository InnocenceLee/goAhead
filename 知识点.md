# 知识点

### 一、自增计算

​	附栈计算过程中前缀表达式、后缀表达式、中缀表达式是对表达式的不同记法，其区别在于**运算符相对于操作数的位置不同**，前缀表达式的运算符位于操作数之前，中缀和后缀同理。

中缀表达式：虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。**对计算机来说，计算前缀或后缀表达式的值非常简单**。

前缀表达式：指的是不包含括号（已经计算的优先顺序已经转换中实现），运算符放在两个运算对象的前面，严格从右向左进行（不再考虑运算符的优先规则），所有的计算按运算符出现的顺序。其计算机求值过程为：

1. 从右至左扫描表达式
2. 遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（**栈顶元素 op 次顶元素**），并将结果入栈
3. 重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

可以看到，用计算机计算前缀表达式是非常容易的，不像计算后缀表达式需要使用正则匹配！

后缀表达式：后缀表达式与前缀表达式类似，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。后缀表达式也被称为后缀记法或**逆波兰式**。

中缀表达式转换为前缀或后缀表达式：

1.人工转换转化步骤：

1. 按照运算符的优先级对所有的运算单位加括号
2. 将运算符移动到对应括号的前面（前缀表达式）或后面（后缀表达式）
3. 去掉括号，得到前缀或后缀表达式

```tex
示例：
中缀表达式：1+(2+3)×4-5
1）加括号
式子变成 ((1+((2+3)×4))-5)
2）移动运算符
对于前缀表达式，变成了 -(+(1×(+(23)4))5)
对于后缀表达式：变成了((1((23)+4)×)+5)-
3）去掉括号
前缀表达式： - + 1 × + 2 3 4 5
后缀表达式：1 2 3 + 4 × + 5 -

```

2.利用表达式数转换

首先将中缀表达式转换为表达式树，然后**后序**（中缀转后缀后序，中缀转前缀则前序遍历）遍历表达式树，所得结果就是后缀表达式。

将中缀表达式转化为表达式树方法：表达式树的树叶是操作数，而其他的节点为操作符，根节点为优先级最低且靠右的操作符（如上述表达式优先级最低的是- 和+，但 -更靠右，所以根为-），圆括号不包括。如上述中缀表达式转换后的表达式树如下：

![img](https://img-blog.csdn.net/20140402144303578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2Fsa2Vya2Fscg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



经过后序遍历表达式树后得到的后缀表达式为：12 3 + 4 * + 5 –

3.利用栈的入栈出栈

​	**从左到右**（中缀转后缀从左到右，中缀转前缀则从右到左）遍历中缀表达式的每个操作数和操作符。当读到**操作数立即把它输出**，即成为后缀表达式的一部分；若读到操作符，判断该符号与栈顶符号的优先级，若该符号优先级高于栈顶元素，则将该操作符入栈，否则就把栈顶运算符弹出并加到表达式尾端，直到遇到优先级低于该操作符的栈元素，然后把该操作符压入栈中。如果遇到左括号（中缀转后缀为左括号，中缀转前缀为右括号）直接压入栈中，如果遇到一个右括号，那么就将栈元素弹出并加到后缀表达式尾端，但左右括号并不输出。最后，如果读到中缀表达式的尾端，将栈元素依次完全弹出并加到后缀表达式尾端。如图：

![img](https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171206082503581-926350583.png)注意：上图中4-2去掉**相等**的条件



### 二、单例设计模式

- 饿汉式：在类初始化时直接创建对象，不存在线程安全问题。

  - 直接实例化饿汉式（简洁直观）。

    ```JAVA
    public class Singleton1{
        public static final Singleton1 instance = new Singleton1();
        private Singleton1(){
        }
    }
    ```

    

  - 枚举式（最简洁）

    ```java
    public enum Singleton2{
        INSTANCE;
    }
    ```

    

  - 静态代码块饿汉式（适合复杂实例化，比如需要读取配置文件初始化某属性）

    附：读取配置文件五种方式

    | 方式 | 描述                                                     | 优点                                                         | 缺点                                                         |
    | ---- | -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 一   | 采用ServletContext读取文件的realpath，然后通过文件流读取 | 可以放在src下面，也可放在web-info及webroot下面等。因为是读取出路径后，用文件流进行读取的，所以可以读取任意的配置文件包括xml和properties | 不能在servlet外面应用读取配置信息。                          |
    | 二   | 采用**ResourceBundle**类读取配置信息                     | 可以以**完全限定类名**的方式加载资源后，直接的读取出来，且可以在非Web应用中读取资源文件。 | 只能加载类classes下面的资源文件，且只能读取.properties文件。 |
    | 三   | 采用ClassLoader方式进行读取配置信息                      | 可以在非Web应用中读取配置资源信息，可以读取任意的资源文件信息。 | 只能加载类classes下面的资源文件。                            |
    | 四   | getResouceAsStream                                       | XmlParserHandler.class.getResourceAsStream 与 classloader 的不同之处在于使用的是当前类的相对路径。 |                                                              |
    | 五   | PropertiesLoaderUtils 工具类                             | Spring 提供的 **PropertiesLoaderUtils** 允许您直接通过基于类路径的文件地址加载属性资源。最大的好处就是：实时加载配置文件，修改后立即生效，不必重启。 |                                                              |

    ```java
    // 方式一
    String realPath = getServletContext().getRealPath(path);
    InputStream reader =new InputStream(newFileInputStream(realPath),"utf-8");
    // 方式二ResourceBundle bundle = new ResourceBundle("com.jwell.fileName");
    ResourceBundle bundle = new ResourceBundle("fileName");
    bundle.getkeys();
    //方式三
    /获取文件流
    InputStream is=TestJava.class.getClassLoader().getResourceAsStream("message.properties");
    //获取文件的位置
    String filePath=TestJava.class.getClassLoader().getResource("message.properties").getFile();
    
    //方式四
    new BufferedReader( 
      new InputStreamReader(
        XmlParserHandler.class.getResourceAsStream("./rain.xml"),  //./代表当前目录不写也可以    
        "GB2312"
      )
    );
    //方式五
    props=PropertiesLoaderUtils.loadAllProperties("message.properties");
    
    ```

    

- 懒汉式（延迟创建对象）

  - 线程不安全（适合单线程）

  - 线程安全形式（Synchronized）（适合多线程）

  - 静态内部类形式（适合多线程）

    附静态内部类形式的懒汉式：

    ​	静态内部类不会自动随着外部类的加载和初始化而初始化，它是需要单独去加载和初始化的，而由于单例对象是在内部类加载和初始化时创建的，所以是线程安全的。

  ```java
  public Singleton{
      private Singleton(){}
      public static class Inner{
      	   private static final Singleton instance = new Singleton();
      }
      private Singleton getInstance(){
          return Inner.instance;
      }
  }
  ```

### 三、类初始化和实例初始化顺序

```java
public class Father{
    private int i = test();
    private static int j = method();
    static{
        System.out.print("1");
    }
    public Father(){
        System.out.print("2");
    }
    {
        System.out.print("3");
    }
    public int test(){
        System.out.print("4");
        return 1;
    }
    public static int method(){
        System.out.print("5");
        return 1;
    }
}

--------------------------------------------------
    public class Son extends Father{
        private int i = test();
        private static int j = method();
        static{
            System.out.print("6");
        }
        Son(){
            System.out.print("7");
        }
        {
            System.out.print("8");
        }
        public int test(){
            System.out.print("9");
            return 1;
        }
        public static int method(){
            System.out.print("10");
            return 1;
        }
        
        public void static main(String[] args){
            Son son = new Son();
            System.out.println();
        }
    }
```

1. 类初始化过程：
   - 一个类要创建实例需要先加载并初始化该类
     - main方法所在的类需要先加载和初始化
   - 子类要初始化必须先初始化父类
   - 一个类初始化就是执行`<clinit>（）`方法
     - `<clinit>()`方法由**静态**类变量**显示赋值**和静态代码块两部分组成
     - 静态类变量显示赋值和静态代码块从上到下（谁在前面就谁先执行）顺序执行
     - `<clinit>（）`方法只会执行一次
2. 实例初始化过程
   - 实例初始化就是执行`init()`方法
     - `init<>`方法可能重载有多个，有几个构造器就有几个方法
     - `init<>`方法主要有非静态**实例变量显示赋值**和实例代码块组成、对应构造器代码组成、
     - 实例变量显示赋值和实例代码块顺序执行，对应构造器代码最后执行
     - 每次创建实例对象，调用对应构造器，执行的就是对应的`init<>`方法
       - `init<>`方法的首行是`super()`或者`super(参数)`（写或不写都存在的），即父类对应的`init<>`方法
   - 
3. 方法的重写override
   - 哪些方法不能被重写
     - final方法
     - 静态方法
     - private等子类中不可见方法
   - 对象的多态性
     - this在构造器中表示的是**正在创建的对象**，所以在创建Son时，执行Super()触发的test()方法，也是调用的子类重写的test()（面向对象的多态）
     - 非静态方法默认调用的对象是this

### 四、方法的参数传递机制

```java
public class Exam{
    public static void main(String[] args){
        int i = 1;
        String str = "hello";
        Integer num = 2；
        int[] arr = {1,2,3,4,5};
        MyData data = new MyData();
        change(i, str, num, arr, data);
  		System.out.print("上述所有值");
    }
    
    private static void change(int i,String str,Integer num,int[] arr,MyData data){
        i += 1;
        str += "world";
        num += 1;
        arr[0] += 1;
        data.a += 1;
    }
    
    class MyData{
        int a = 10;
    }
}
```

![1572506541877](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572506541877.png)

- 形参是基本数据类型
  - 传递数据值
- 形参是引用数据类型
  - 传递地址值
  - 特殊的类型：**Sting、包装类等对象不可变性**

### 五、递归和迭代

```java
//递归解决
public int recursion(int n){
    if(n == 1 || n ==2)
        return n;
    return recursion(n-1) + recursion(n-2);
}

//循环迭代解决
public int loop(int n){
    if(n == 1 || n ==2)
        return n;
    //初始化为走到第二级台阶的走法
    int one = 2;
    //初始化为走到第一级台阶的走法
    int two = 1;
    int sum = 0;
    for(int i = 3; i <= n; i++){
        sum = one + two;
        one = sum;
        two = one;
    }
    return sum;
}
```

- 方法调用自身叫做递归，利用变量的原值推出新值成为迭代
- 递归代码精简，可读性好，但浪费空间，且递归太深易造成堆栈溢出
- 迭代运行效率好，时间只随循环次数增加，但是可读性差

### 六、成员变量与局部变量

![1572507881460](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572507881460.png)

- 就近原则

- 局部变量与成员变量的区别

  1.声明位置

  - 局部变量：方法体{}中，形参，代码块{}中
  - 成员变量：类中但在方法外
    - 类变量：有static修饰
    - 实例变量：没有static修饰

  2.修饰符

  - 局部变量：final
  - 成员变量：public/protected/private/final/static/volatile/transient

  3.值存储位置

  - 局部变量：栈中
  - 成员变量：实例变量存在堆中，类变量存在方法区中

  4.作用域：

  - 局部变量：从申明处开始，到所属｝结束
  - 实例变量：当前类this.（有时this可缺省）访问，其他类"实例."访问
  - 类变量：当前类 类名.（有时类名可缺省）访问，在其他类中可以“类名.”或者"实例."访问

  5.生命周期：

  - 局部变量：每一个线程，每一次调用执行都是新的生命周期
  - 实例变量：每个对象的实例 变量都是独立的，跟随对象的生命周期。
  - 类变量：该类的所有对象的类变量是共享的，跟随类的生命周期（初始化而初始化，卸载而消亡）

![1572508442602](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572508442602.png)

### 七、Spring Bean的作用域之间区别

- singleton：默认该模式
- prototype：原型模式，每次getBean获取创建一个实例
- request：每一次http请求都会创建一个新的bean，仅适用于WebApplicationContext环境
- session：同一session回话共享一个bean，仅适用于WebApplicationContext环境

### 八、spring支持的常用数据库事务传播属性和隔离级别

### 九、过滤器和拦截器

过滤器与拦截器的区别：

​	1、Filter是依赖于Servlet容器，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。

　　2、Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理的方式来执行。

　　3、Filter的生命周期由Servlet容器管理，而拦截器则可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。

### 十、SpringMVC的简单处理流程

![1572592646350](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572592646350.png)

### 十一、实体的字段名和数据库表的列名匹配

- 查询起别名
- mybatis配置文件中开启驼峰命名转换（mapUnderscoreToCamelCase属性）
- resultMap

### 十二、git分支操作

- 创建分支 

  ```shell
  -- 创建分支
  git branch <新分支> 
  -- 查看分支
  git branch -v 
  ```

- 切换分支

  ```shell
  git checkout <分支名> 
  git checkout -b <分支名> //创建分支并切换！
  ```

- 合并分支

  ```shell
  git checkout A//先切换到A分支
  git merge B //将B合并到A上
  ```

- 删除分支

  ```shell
  git branch -D <分支>  //注意删除某分支时需先切换到其他分支
  ```

### 十三、redis持久化

- RDB（Redis Database）

  fork一个子进程（写时复制）以Snapshot方式做全量存储，不影响主进程，但可能丢失最后一次持久化的数据。

- AOF (Append Of File)

  以日志的方式记录每个写操作，只能追加不能删除。

### 十四、数据库索引

​	group by实际是先排序再分组，故包含order by。

### 十五、java垃圾回收

​	![1572852536753](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572852536753.png)

- GC(分代收集算法)垃圾回收发生在jvm中的堆部分：
  - 次数上频繁收集的Young区(Minor GC)
  - 次数上较少收集的Old区（Full GC）
  - 基本不动Perm区

- GC主要算法：

  - 引用计数法（已被JVM废弃，原因是每次赋值都需要维护引用计数器；难以处理循环引用）

  - 复制算法（Young区中使用的是Minor GC，这种GC算法采用的是复制算法）

    ​	![1572852877489](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572852877489.png)

  - 标记清除（老年代一般是由标记清除或者是标记清除与标记整理压缩的混合实现）

    ![1572853033080](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572853033080.png)

  - 标记压缩（老年代）

    ![1572853121624](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572853121624.png)

- 

### 十六、ElasticSearch和Solr的区别

![1572857490143](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572857490143.png)

### 十七、布隆过滤器与Counting Bloom Filter（解决删除问题）

​布隆过滤器的原理是，当⼀个元素被加⼊集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K
个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（⼤约）知道集合中有没有它了：如
果这些点有任何⼀个0，则被检元素⼀定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的
基本思想。

缺点：

- 存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果
  bloom filter中存储的是⿊名单，那么可以通过建⽴⼀个⽩名单来存储可能会误判的元素。
- 删除困难。⼀个放⼊容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为
  0，可能会影响其他元素的判断。可以采⽤Counting Bloom Filter	

实现：

​	布隆过滤器有许多实现与优化，Guava中就提供了⼀种Bloom Filter的实现。
在使⽤bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp，
在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的⼤⼩。
对于⼀个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数
组的⼤⼩m，以及hash函数的个数k，并选择hash函数。

场景：

垃圾邮件过滤。如果⽤哈希表，每存储⼀亿个 email地址，就需要 1.6GB的内存（⽤哈希表实现的
具体办法是将每⼀个 email地址对应成⼀个⼋字节的信息指纹，然后将这些信息指纹存⼊哈希表，
由于哈希表的存储效率⼀般只有 50%，因此⼀个 email地址需要占⽤⼗六个字节。⼀亿个地址⼤约
要 1.6GB，即⼗六亿字节的内存）。因此存贮⼏⼗亿个邮件地址可能需要上百 GB的内存。⽽
Bloom Filter只需要哈希表 1/8到 1/4 的⼤⼩就能解决同样的问题。

示例：

不安全网页的黑名单包含100亿个黑名单网页，每个网页的URL最多占用64字节。现在想要实现一种网页过滤系统，可以根据网页的URL判断该网站是否在黑名单上，请设计该系统。要求该系统允许有万分之一以下的判断失误率，并且使用的额外空间不要超过30G。

解题：布隆过滤器的bitarray大小如何确定？

设bitarray大小为m，样本数量为n，失误率为p。
由题可知 n = 100亿，p = 0.01%
单个样本大小不影响布隆过滤器大小，因为样本会通过哈希函数得到输出值。
使用样本数量n和失误率p可以算出m，公式为：

![å¬å¼](https://img-blog.csdnimg.cn/20190521165248851.png)

求得 m = 19.19n，向上取整为 20n。所以2000亿bit，约为25G。
所使用哈希函数个数k可以由以下公式求得：

![å¬å¼](https://img-blog.csdnimg.cn/2019052116540727.png)

所以 k = 14，即需要14个哈希函数。
通过 m = 20n， k = 14，可以通过以下公式算出设计的布隆过滤器的真实失误率为0.006%。

![å¬å¼](https://img-blog.csdnimg.cn/20190521165657494.png)

BloomFilter的应用
黑名单
比如邮件黑名单过滤器，判断邮件地址是否在黑名单中
排序(仅限于BitSet)
仔细想想，其实BitSet在set(int value)的时候，“顺便”把value也给排序了。
网络爬虫
判断某个URL是否已经被爬取过
K-V系统快速判断某个key是否存在
典型的例子有Hbase，Hbase的每个Region中都包含一个BloomFilter，用于在查询时快速判断某个key在该region中是否存在，如果不存在，直接返回，节省掉后续的查询。



### mysql更新

mysql当执行一句update语句，但修改内容与原数据一致时，mysql本神返回的  受影响行数为0 ，在 控制台或者 客户端如navicat中都可看到。但jdbc/mybatis 返回的却是1，返回的是 sql语句 的匹配行数。

JDBC默认返回的是符合的行数Rows matched， 如果想返回修改过（ Changed）的行数  ，需要使用useAffectedRows参数。附上该参数修改方式：

```yml
jdbc:mysql://ip:port/db? useAffectedRows=true&…
-- useAffectedRows的含义 ： 是否用受影响的行数替代查找到的行数来返回数据，也就是查找到了 但却不一定真正修改了
```



当使用mysql条件更新时--最先让人想到的写法  

UPDATE buyer SET is_seller=1 WHERE uid IN (SELECT uid FROM seller) 

此语句是错误的，会报错 You can't specify target table 'xxx' for update in FROM

 

这是因为：

mysql的update的一些特点

1、update 时，更新的表不能在set和where中用于子查询；

2、update 时，可以对多个表进行更新（sqlserver不行）；

​         如：update ta a,tb b set a.Bid=b.id ,b.Aid=a.id;  

3、update 后面可以做任意的查询，这个作用等同于from；

##### 十八、MySQL UPDATE JOIN语法

我们经常使用`join`子句来查询表中的行(在[INNER JOIN](http://www.yiibai.com/mysql/inner-join.html)的情况下)，或者可能没有(在[LEFT JOIN](http://www.yiibai.com/mysql/left-join.html)的情况下)另一个表中的相应行。 在MySQL中，可以在[UPDATE语句](http://www.yiibai.com/mysql/update-data.html)中使用`JOIN`子句执行跨表更新。

MySQL `UPDATE JOIN`的语法如下：

```sql
UPDATE T1, T2,
[INNER JOIN | LEFT JOIN] T1 ON T1.C1 = T2. C1
SET T1.C2 = T2.C2, 
    T2.C3 = expr
WHERE condition
```

SQL

让我们更详细地看看MySQL `UPDATE JOIN`语法：

- 首先，在`UPDATE`子句之后，指定主表(`T1`)和希望主表连接表(`T2`)。 请注意，必须在`UPDATE`子句之后至少指定一个表。`UPDATE`子句后未指定的表中的数据未更新。
- 第二，指定一种要使用的连接，即`INNER JOIN`或`LEFT JOIN`和连接条件。`JOIN`子句必须出现在`UPDATE`子句之后。
- 第三，要为要更新的`T1`和/或`T2`表中的列分配新值。
- 第四，[WHERE子句](http://www.yiibai.com/mysql/where.html)中的条件用于指定要更新的行。

如果您学习过了[UPDATE语句教程](http://www.yiibai.com/mysql/update-data.html)，您可能会注意到使用以下语法更新数据交叉表的另一种方法：

```sql
UPDATE T1, T2
SET T1.c2 = T2.c2,
      T2.c3 = expr
WHERE T1.c1 = T2.c1 AND condition
```

SQL

在这个`UPDATE`语句与具有隐式`INNER JOIN`子句的`UPDATE JOIN`工作相同。这意味着可以如下重写上述语句：

```sql
UPDATE T1,T2
INNER JOIN T2 ON T1.C1 = T2.C1
SET T1.C2 = T2.C2,
      T2.C3 = expr
WHERE condition
```



mysql插入：

1.insert into values

2.insert into select 



@NotEmpty、@NotNull、@NotBlank的区别 
1 @NotEmpty :不能为null，且Size>0 （有@NotEmpty注解的String、Collection、Map、数组是不能为null或长度为0，只能用于这四种类型）
2 @NotNull:不能为null，但可以为empty,没有Size的约束 （带注释的元素不能为null。接受任何类型。完美！）
3 @NotBlank:只用于String,不能为null且trim()之后size>0（此注解只能用于验证String类型，不能为空格）

**mysql多表查询时必须起别名。**

mysql的group_concat函数完整表达式

```
GROUP_CONCAT([DISTINCT] expr [,expr ...]
             [ORDER BY {unsigned_integer | col_name | expr}
                 [ASC | DESC] [,col_name ...]]
             [SEPARATOR str_val])
```

##### 十九、索引失效情况：

如果是同样的sql如果在之前能够使用到索引，那么现在使用不到索引，以下几种主要情况:

> 1. 随着表的增长，where条件出来的数据太多，大于15%，使得索引失效（会导致CBO计算走索引花费大于走全表）
> 2. 统计信息失效 需要重新搜集统计信息
> 3. 索引本身失效 需要重建索引

具体情况：

**1.单独引用复合索引里非第一位置的索引列**

> 假如有INDEX(a,b,c)， 
> 当条件为a或a,b或a,b,c时都可以使用索引， 
> 但是当条件为b,c时将不会使用索引。
>
> **复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。**因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。

2.**对索引列运算**，运算包括（+、-、*、/、！、<>、%、**like’%_’（%放在前面）**、or、in、exist等），导致索引失效。

> 错误的例子：select * from test where id-1=9; 
> 正确的例子：select * from test where id=10; 
> **注意！！** 
> mysql sql 中如果使用了 **not in ， not exists ， （<> 不等于 ！=） 这些不走** 
> < 小于 > 大于 <= >= 这个根据实际查询数据来判断，**如果全盘扫描速度比索引速度要快则不走索引** 。

3.**对索引应用内部函数**，这种情况下应该建立基于函数的索引。

> select * from template t where ROUND(t.logicdb_id) = 1 
> 此时应该建ROUND(t.logicdb_id)为索引。

4、**类型错误**，如字段类型为varchar，where条件用number。

> 例：template_id字段是varchar类型。
>
> 错误写法：select * from template t where t.template_id = 1
>
> 正确写法：select * from template t where t.template_id = ‘1’

5.**如果MySQL预计使用全表扫描要比使用索引快，则不使用索引** 
6.**like的模糊查询以%开头，索引失效** 
7.**索引列没有限制 not null**，索引不存储空值，如果不限制索引列是not null，oracle会认为索引列有可能存在空值，所以不会按照索引计算

------

## 索引注意事项

<https://blog.csdn.net/qq_16239775/article/details/79665972>

**1.索引不会包含有NULL值的列**

**只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。**所以我们在数据库设计时**不要让字段的默认值为NULL。应该用0、一个特殊的值或者一个空串代替空值。**

**2.复合索引**

比如有一条语句是这样的：`select * from users wherearea=’beijing’ and age=22;`如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area,age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该**将最常用作限制条件的列放在最左边，依次递减**。

**3.使用短索引**

对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。**短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。**

**4.排序的索引问题**

mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此**数据库默认排序可以符合要求的情况下不要使用排序操作**；**尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引**。

**5.like语句操作**

一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。**like“%aaa%” 不会使用索引而like“aaa%”可以使用索引。**

**6.不要在列上进行运算**

select* from users where YEAR(adddate)

**7.不使用NOT IN操作**

NOT IN操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替

## 如何选择合适的列创建索引

1 在**经常需要搜索的列**上，可以加快搜索的速度；

2 在**作为主键的列**上，**强制该列的唯一性和组织表中数据的排列结构**；

3 在**经常用在连接的列**上，这些列主要是一些外键，可以**加快连接的速度**；

4 在**经常需要根据范围进行搜索的列上创建索引**，因为索引已经排序，其指定的范围是连续的；这样查询可以利用索引的排序，加快排序查询时间；

5 在**经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度**。当增加索引时，会提高检索性能，但是会降低修改性能

6 **唯一性很差的字段不合适做索引**，如性别

7 **更新频繁的字段不适合**，耗时且影响性能

## 索引分类

索引可以分为簇索引和非簇索引

> 簇索引通过重排表中的数据来提高数据的访问速度， 
> 非簇索引则通过维护表中的数据指针来提高数据的索引。

聚簇索引的体系结构：

索引的结构类似于树状结构，树的顶部称为叶级，树的其它部分称为非叶级，树的根部在非叶级中。同样，在聚簇索引中，聚簇索引的叶级和非叶级构成了一个树状结构，索引的最低级是叶级。在聚簇索引中，表中的数据所在的数据页是叶级，在叶级之上的索引页是非叶级，索引数据所在的索引页是非叶级。在聚簇索引中，数据值的顺序总是按照升序排列。应该在表中经常搜索的列或者按照顺序访问的列上创建聚簇索引。

当创建聚簇索引时，应该考虑这些因素：

（1）**每一个表只能有一个聚簇索引**，因为表中数据的物理顺序只能有一个；

（2）**表中行的物理顺序和索引中行的物理顺序是相同的**，**在创建任何非聚簇索引之前创建聚簇索引**，这是因为聚簇索引改变了表中行的物理顺序，数据行 按照一定的顺序排列，并且自动维护这个顺序；

（3）关键值的唯一性要么使用UNIQUE关键字明确维护，要么由一个内部的唯一标识符明确维护，这些唯一性标识符是系统自己使用的，用户不能访问；

（4）聚簇索引的平均大小大约是数据表的百分之五，但是，实际的聚簇索引的大小常常根据索引列的大小变化而变化；

（5）在索引的创建过程中，SQL Server临时使用当前数据库的磁盘空间，当创建聚簇索引时，需要1.2倍的表空间的大小，因此，一定要**保证有足够的空间来创建聚簇索引**。





## 递归

```
程序调用自身的编程技巧称为递归（ recursion）。 
递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模
较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
```

## 回溯

### 思路

```
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
```

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。

**回溯的思路**基本如下：当前局面下，我们有若干种选择，所以我们对每一种选择进行尝试。如果发现某种选择违反了某些限定条件，此时 return；如果尝试某种选择到了最后，发现该选择是正确解，那么就将其加入到解集中。 
在这种思想下，我们需要清晰的找出三个要素：选择 (Options)，限制 (Restraints)，结束条件 (Termination)。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择（递归清空该正确解的所有选择，为下一解腾位置）
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。**



## 避免泛型擦除方法

#### 方案一：利用成员变量保留泛型

理论依据：成员变量的泛型类型不会被擦除

```java
@Test
public void test6() throws JsonProcessingException {
    ObjectMapper objectMapper = new ObjectMapper();

    System.out.println("----------读集合类型----------");
    Data data = objectMapper.readValue("{\"ids\" : [1,2,3]}", Data.class);

    Long id = data.getIds().get(0);
    System.out.println(id);
}


@lombok.Data
private static class Data {
    private List<Long> ids;
}
12345678910111213141516
```

运行程序，一切正常：

```java
----------读集合类型----------
1
12
```

#### 方案二：使用官方推荐的`TypeReference<T>`

官方早早就为我们考虑好了这类泛型擦除的问题，所以它提供了`TypeReference<T>`方便我们把泛型类型保留下来，使用起来是非常的方便的：

```java
@Test
public void test7() throws JsonProcessingException {
    ObjectMapper objectMapper = new ObjectMapper();

    System.out.println("----------读集合类型----------");
    List<Long> ids = objectMapper.readValue("[1,2,3]", new TypeReference<List<Long>>() {
    });

    Long id = ids.get(0);
    System.out.println(id);
}
```