#### 插入排序

```java
private int[] insertSort(int[] nums){
        for (int i = 1; i < nums.length; i++) {
            int current = nums[i];
            int j = i - 1;

            while(j >= 0 && nums[j] > current){
                nums[j+1] = nums[j];
                j--;
            }
            nums[j+1] = current;
        }
        return nums;
    }
```

#### 冒泡排序

**(变量控制如果没有发生交换，则结束循环)**

它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

```java
private int[] bubbleSort(int[] nums){
        for (int i = 1; i < nums.length; i++) {
            boolean noChange = true;
            for (int j = 0; j < nums.length - i; j++) {
                if(nums[j] > nums[j+1]){
                    int temp = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = temp;
                    noChange = false;
                }
            }
            if(noChange){
                break;
            }
        }
        return nums;
    }
```

#### 选择排序

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

```java
private int[] chooseSort(int[] nums){
        for (int i = 0; i < nums.length; i++) {
            int minIndex = i;
            for (int j = i+1; j < nums.length; j++) {
                if(nums[j] < nums[minIndex]){
                    minIndex = j;
                }
            }
            int temp = nums[i];
            nums[i] = nums[minIndex];
            nums[minIndex] = temp;
        }
        return nums;
    }
```

#### 希尔排序

也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列**以步长分割成为若干子序列**分别进行直接插入排序，待整个序列中的记录"基本有序"时，最后步长递减为1时即对全体记录进行依次直接插入排序。

```java
private int[] shellSort(int[] nums) {
        //设置希尔增量
        int step = nums.length / 2;
        while (step >= 1) {
            for (int i = step; i < nums.length; i += step) {
                int current = nums[i];
                int j = i - step;
                while (j >= 0 && nums[j] > current) {
                    nums[j + step] = nums[j];
                    j -= step;
                }
                nums[j + step] = current;
            }
            step /= 2;
        }
        return nums;
    }
```

#### 快速排序

​	简单就是选择一个基准值，然后将所有比它小的元素放到其左边，比大的元素放到其右边，然后再分别对两侧的子序列进行同样的操作，最终得到一个有序序列。即快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

*快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。*

```java

public int[] quickSort(int[] nums, int left, int right){
    if(left < right){
        int index = partition1(nums, left, right);//调用1或者2
        quickSort(nums, left, index-1);
        quickSort(nums, index+1, right);
    }
}

public int partition1(int[] nums, int left, int right){
    int pivotIdx = left;
    //深刻理解此处index指针的意义是记录[pivotIdx+1, index-1]区间均为小于或等于基准值的元素
    //相当于只要发现比基准值小的，就与index位置值交换且index加1
    int index = pivotIdx + 1;
    for(int i = index; i <= right; i++){
        if(nums[i] <= nums[pivotIdx]){
            int temp = nums[index];
            nums[index] = nums[i];
            nums[i] = temp;
            index++;
        }
    }
    int temp = nums[pivotIdx];
    nums[pivotIdx] = nums[index-1];
    nums[index-1] = nums[pivotIdx];
    return index-1;
}
//该种方式是左右两边同时找
public int partition2(int[] nums, int left, int right){
    int pivot = nums[left];
    while(left < right){
        //从右边依次找到一个比基准值小的元素下标
        while(left < right && nums[right] >= pivot){
            right--;
        }
        nums[left] = nums[right]; //将该小值赋值到left处
        //再从左边依次找到一个大于基准值的元素
        while(left < right && nums[left] <= pivot){
            left++;
        }
        nums[right] = nums[left];//将大于基准值的该元素放到right处
        
    }
    nums[left] = pivot;
    return left;
}
```

#### 归并排序

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。**归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。**

简单讲就是：先将数组拆分成单个元素（单个也即有序），然后通过merge两个有序数组成一个合并后的有序数组，直到得到最终的有序数组。

```java
public int[] guiBingSort(int[] nums){
    if(nums.length <= 1){
        return nums;
    }else{
        int mid = nums.length / 2;
        int[] left = Arrays.copyOfRange(nums, 0, mid);
        int[] right = Arrays.copyOfRange(nums, mid, nums.length);
        return merge(guiBingSort(left), guiBingSort(right));
    }
    
}

//合并两个有序数组
public int[] merge(int[] left, int[] right){
    int[] result = new int[left.length+right.length];//结果数组
    int index = 0; //结果数组下标
    int i = 0; //left遍历下标
    int j = 0;//right遍历下标
    //只要left或right有一个未全部遍历则循环遍历
    while(i < left.length || j < right.length){
        if(i >= left.length){ //left遍历完，说明只剩right有序元素，直接填充result
            result[index++] = right[j++];
        }else if(j >= right.length){//同理
            result[index++] = left[i++];
        }else if(left[i] < right[j]){ //即两个数组都没有遍历完，则比较当前元素大小，谁小谁先填充
            result[index++] = left[i++];
        }else{
            result[index++] = right[j++];
        }
    }
    return result;
}
```

#### 堆排序

首先明确概念：

- 大顶堆：任何一个节点都大于或等于他的左右子节点，用以实现升序排列。
- 小顶堆：任何一个节点都小于或等于他的左右子节点，用以降序排列。
- 完全二叉树：除叶子节点外，所有节点均拥有两个子节点；叶子节点全部集中在左侧。大小顶堆都是完全二叉树。

堆排序（以升序排列说明）原理就是通过构建大顶堆（节点i的左子节点为2*i+1，右子节点为2*i+2），然后将顶元素与数组尾部元素交换，再调整堆为大顶堆，依次交换直到全部有序。

```java
//假设两个元素i和j的交换方式为swap(nums, i, j)

//堆排序最终方法
public int[] heapSort(int[] nums){
    createHeap(nums);//初始化
    int len = nums.length;
    for(int i = len-1; i >=0 i--){
        swap(nums, 0, i);//对原有的大顶堆交换顶元素，即取出当前堆最大值，交换后堆被破坏
        len--;//交换一次，即需要排序序的元素少一个
        adjust(nums, 0, len);//对破坏的堆进行调整，由于交换所以破坏处是在顶元素即索引为0处
    }
}

//初始化大顶堆的方法
public void createHeap(int[] nums){
    //找到开始需要调整的最大索引，其实只需要找到nums中最大的父节点即可，但是由于不需要过于精确，只要保证index的值大于或等于最大父节点即可，甚至你可以直接从nums.length处开始
    int index = nums.length / 2; 
    //由于是初始化大顶堆，即从index节点开始往下调整完成后，再依次循环上面的节点往下调整，有点类似先将子节点树调整完毕，然后再去调整父节点。
    for(int i = index; i >= 0; i--){
        adjust(nums, i, len);
    }
}


/**
*该方法为调整堆方法，可理解为nums原本是大顶堆，然后index处元素发生了变化，即需要调整该变化影响到的所有*节点（范围在index~len内, 因为len会不断变小，可视为未排序元素的长度）。
*nums为待调整数组，index为调整的节点，len为当前调整长度
* 
*/
public void adjust(int[] nums, int index, int len){
    int left = 2*index + 1;//左子节点
    int right = 2*index + 2;//右子节点
    int largerIdx = index; //记录比当前index节点的最大子节点索引
    if(left < len && nums[left] > nums[largerIdx]){
        largerIdx = left;
    }
    if(right < len && nums[right] > nums[largerIdx]){
        largerIdx = right;
    }
    //细节来了，如果不相等，说明子节点有比index节点大的值则需要交换值，并且由于交换后子节点的值也发生了变化，故需要继续调整子节点以符合大顶堆；如果largerIdx和index相等，由于原始nums已经是大顶堆，所以就不需要继续往下调整了。
    if(largerIdx != index){
        swap(nums, index, largerIdx);
        adjust(nums, largerIdx, len);
    }
}
```

#### 计数排序

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，**计数排序要求输入的数据必须是有确定范围的整数**。**即找到数组中最大值k，然后创建一个长度为k的数组C，遍历原数组元素，在数组C的对应下标处记录出现次数。**最后再遍历数组C，一次输出下标即可。由于简单则不贴代码了。

