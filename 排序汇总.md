插入排序：

```java
private int[] insertSort(int[] nums){
        for (int i = 1; i < nums.length; i++) {
            int current = nums[i];
            int j = i - 1;

            while(j >= 0 && nums[j] > current){
                nums[j+1] = nums[j];
                j--;
            }
            nums[j+1] = current;
        }
        return nums;
    }
```

冒泡排序：(变量控制如果没有发生交换，则结束循环)

它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

```java
private int[] bubbleSort(int[] nums){
        for (int i = 1; i < nums.length; i++) {
            boolean noChange = true;
            for (int j = 0; j < nums.length - i; j++) {
                if(nums[j] > nums[j+1]){
                    int temp = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = temp;
                    noChange = false;
                }
            }
            if(noChange){
                break;
            }
        }
        return nums;
    }
```

选择排序：

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

```java
private int[] chooseSort(int[] nums){
        for (int i = 0; i < nums.length; i++) {
            int minIndex = i;
            for (int j = i+1; j < nums.length; j++) {
                if(nums[j] < nums[minIndex]){
                    minIndex = j;
                }
            }
            int temp = nums[i];
            nums[i] = nums[minIndex];
            nums[minIndex] = temp;
        }
        return nums;
    }
```

希尔排序：

也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列**以步长分割成为若干子序列**分别进行直接插入排序，待整个序列中的记录"基本有序"时，最后步长递减为1时即对全体记录进行依次直接插入排序。

```java
private int[] shellSort(int[] nums) {
        //设置希尔增量
        int step = nums.length / 2;
        while (step >= 1) {
            for (int i = step; i < nums.length; i += step) {
                int current = nums[i];
                int j = i - step;
                while (j >= 0 && nums[j] > current) {
                    nums[j + step] = nums[j];
                    j -= step;
                }
                nums[j + step] = current;
            }
            step /= 2;
        }
        return nums;
    }
```

快速排序：

