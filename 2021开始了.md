### 一、二分查找

**思路很简单，细节是魔鬼。**

1、计算 mid 时需要技巧防止溢出，建议写成: **mid = left + (right - left) / 2**

2、注意while循环结束条件、left、mid、right变化

寻找目标值，返回下标

```java
int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while(left <= right){
        int mid = (left + right) / 2;
        if(nums[mid] == target){
            return mid;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else if(nums[mid] > target){
            right = mid - 1;
        }
    }
    return -1;
}
```

- 为什么 while 循环的条件中是 <=，而不是 < ？

  答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。我们这个算法中使用的是 [left, right] 两端都闭的区间。**这个区间就是每次进行搜索的区间，我们不妨称为「搜索区间」(search space)**。 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。while(left <= right)的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见**这时候搜索区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

- 为什么 left = mid + 1，right = mid - 1？

  刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，如何确定下一步的搜索区间呢？当然是去搜索 [left, mid - 1] 或者 [mid + 1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。



#### 1、搜索旋转数组

题1之[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

> 整数数组 nums 按升序排列，数组中的值 互不相同 。
>
> 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
>
> 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。
>
> ```
> 输入：nums = [4,5,6,7,0,1,2], target = 0
> 输出：4
> ```

第一次做法（自己实现）：

- 首先遍历得出被旋转的个数（即有多少个元素被移动到了尾部）
- 然后根据移动个数，将原数组重新生成新数组。即排序。
- 然后在排序新数组中用二分查找法定位目标值，然后根据旋转的个数计算出原数组的下标值

```java
public int search(int[] nums, int target) {
        if(nums.length <= 1){
            return nums[0] == target ? 0 : -1;
        }
        int index = 1;
        while(index < nums.length && nums[index] > nums[index-1]){
            index++;
        }
        //被翻转了多少个，3
        int count = nums.length - index;
        int[] result = new int[nums.length];
        //native操作
        System.arraycopy(nums, index, result, 0, count);
        System.arraycopy(nums, 0, result, count, index);
        int start =0;
        int end = result.length - 1;
        while(start <= end){
            int mid = (end + start) / 2;
            if(result[mid] == target){
                return mid < count ? mid + index : mid - count;
            }else if(result[mid] < target){
                start = mid + 1;
            }else if(result[mid] > target){
                end = mid - 1;
            }
        }
        return -1;
    }
```

以上实现就是笨！！

题解后做法：**直接二分查找！**

分析：被旋转的数组二分查找时，从mid出切分，必然至少一边是有序的！如此我们在二分查找过程中，判断哪边是有序的，然后分情况缩小查找范围即可！

```java
public int search3(int[] nums, int target){
        if(nums.length <= 1){
            return nums[0] == target ? 0 : -1;
        }
        int len = nums.length;
        int start = 0;
        int end = len - 1;
        while(start <= end){
            int mid = (start + end) / 2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] >= nums[start]){
                //左边有序,需判断是否在左边区间内
                if(nums[start] <= target && target < nums[mid]){
                    end = mid - 1;
                }else {
                    start = mid + 1;
                }
            }else {
                //右边有序,判断是否在右侧区间内
                if(nums[mid] < target && target <= nums[end]){
                    end = mid - 1;
                }else {
                    start = mid + 1;
                }
            }
        }
        return -1;
    }
```

变形：

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
> ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。
>
> 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。
>
> 该题是以上的延伸，本题中nums数组元素可以重复。

分析二分查找法：

由于数组元素存在重复，所以仅靠`nums[mid] >= nums[start]`无法判断出左边是有序的，此时可以拆分为两个条件：**`nums[mid] > nums[start]`时左边一定有序，如果`nums[mid]==nums[start]`，此时只需要将start++即可。**

```java
public boolean search4(int[] nums, int target){
    	if(nums.length <= 1){
            return nums[0] == target;
        }
        int len = nums.length;
        int start = 0;
        int end = len - 1;
        while(start <= end){
            int mid = (start + end) / 2;
            if(nums[mid] == target){
                return true;
            }
            if(nums[mid] == nums[start]){
                start++;
                continue;
            }
            if(nums[mid] >= nums[start]){
                //左边有序,需判断是否在左边区间内
                if(nums[start] <= target && target < nums[mid]){
                    end = mid - 1;
                }else {
                    start = mid + 1;
                }
            }else {
                //右边有序,判断是否在右侧区间内
                if(nums[mid] < target && target <= nums[end]){
                    end = mid - 1;
                }else {
                    start = mid + 1;
                }
            }
        }
        return false;
    }
```

#### 2、旋转数组找最小值

> 153：假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。
>
> 请找出其中最小的元素。
>

还是通过相同的二分查找方式，如果某一区间有序，则只需取该区间第一个，然后到另一区间搜索即可。

```java
public int findMin(int[] nums){
        int current = nums[0];
        int start = 0;
        int end = nums.length - 1;
        while(start <= end){
            int mid = (start + end) / 2;
            if(nums[mid] >= nums[start]){
                //左侧有序，只需取该区间第一个最小的值更新，然后跳到另一个区间即可
                if(nums[start] < current){
                    current = nums[start];
                }
                start = mid + 1;
            }else {
                //右侧有序
                if(nums[mid] < current){
                    current = nums[mid];
                }
                end = mid - 1;
            }
        }
        return current;
    }
}
```

旋转数组最小值变种（可重复）【154】：

> 154：假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
> ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
>
> 请找出其中最小的元素。
>
> 注意数组中可能存在重复的元素。
>

与普通版不同的关键点还是在如果`nums[mid]==nums[start]`，此时只需要将start++即可。

```java
int current = nums[0];
        int start = 0;
        int end = nums.length - 1;
        while(start <= end){
            int mid = (start + end) / 2;
            if(nums[mid] < current){
                current = nums[mid];
            }//如果相等，start++
            if(nums[mid] == nums[start]){
                start++;
                continue;
            }
            if(nums[mid] > nums[start]){
                //左侧有序
                if(nums[start] < current){
                    current = nums[start];
                }
                start = mid + 1;
            }else {
                //右侧有序
                if(nums[mid] < current){
                    current = nums[mid];
                }
                end = mid - 1;
            }
        }
        return current;
```

#### 3、两个有序数组中查询中位数

> 给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

如果直接排序后生成新数组查找，时间复杂度为O(m+n)。题目要求复杂度为O(log(m+n))。

###### 题解一之通用化成【求两个有序数组中第K小的元素】：

```
/* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
 * 这里的 "/" 表示整除
 * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
 * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
 * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
 * 这样 pivot 本身最大也只能是第 k-1 小的元素
 * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
 * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
 * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
 */
```

```java
//题解
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int size = nums1.length + nums2.length;
        double k1MinValue = getNumberKMinValue(nums1, nums2, size / 2 + 1);
        if(size % 2 == 1){
            return k1MinValue;
        }else {
            double numberKMinValue = getNumberKMinValue(nums1, nums2, size / 2);
            return (numberKMinValue + k1MinValue) / 2.0;
        }

 }

/**
*表示从两个数组中查找出第k小的元素
*/
private getNumberKMinValue(int[] nums1, int[] nums2, int k){
 	int i = 0;
    int j = 0;
    while(true){
        //循环结束条件
        if(i == nums1.length){
            return nums2[j+k-1];
        }else if(j == nums2.length){
            return nums1[i+k-1];
        }
        if(k == 1){
            return Math.min(nums1[i], nums2[j]);
        }
        //正常情况，按半切分剔除,先各拿half个元素出来，取二者尾部处最小的，即能确定该值在两个数组中至少比half个元素小
        int half = k / 2;
        int newIndex1 = Math.min(i+half, nums1.length)-1;
        int newIndex2 = Math.min(j+half, nums2.length)-1;
        if(nums1[newIndex1] <= nums2[newIndex2]){
            //nums1中half处元素更小，则更新k值，且此时由于[i, half]已参与比较故需“删除”该部分即更新i值
            k -= newIndex1 - i + 1;
            i = newIndex1 + 1;
        }else{
    		k -= newIndex2 -i + 1;
            j = newIndex2 + 1;
        }
    }
}
```

###### 题解二：**划分数组**。

分析一下数组中位数（比如i处为中位数索引）的性质：

- 数组为奇数时，左边部分的元素个数len1 = 右边元素个数len2 + 1，数组为偶数时len1=len2;

- 同时左边最大的元素max(left) <= min(right)右边最小的元素

  

那么为偶数时，假如{A,B} 中的所有元素已经被划分为相同长度的两个部分，且前一部分中的元素总是小于或等于后一部分中的元素。中位数就是前一部分的最大值和后一部分的最小值的平均值：
$$
median= 

\frac{max(left\_part)+min(right\_part)}{2}
​
$$
奇数时，{A,B} 中的所有元素已经被划分为两个部分，前一部分比后一部分多一个元素，且前一部分中的元素总是小于或等于后一部分中的元素。中位数就是前一部分的最大值：

$$
median=max(left\_part)
$$
因此可以搜索数组A，根据枚举的i值去确定j值（因为i+j = (len1+len2)/2）,然后得出满足条件的median值。

```java
public double findMedianSortedArrays2(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        int cutI = 0;
        int cutJ;
        int leftMedium = 0;
        int rightMedium = 0;
        //int leftLen = cutI + 1 + cutJ + 1; int rightLen = len1 + len2 - leftLen
        // 二者要相等，即可得等式cutI + cutJ = (len1 + len2) / 2
        //枚举cutI的值，根据cutI的值来确定cutJ的值，以满足前部分数组的最大值小于等于后部分数组的最小值
        while(cutI <= len1){
            cutJ = (len1 + len2 + 1) / 2 - cutI; //前半部分多一个元素
            //nums1数组分割后前部分的最大值
            int nums_im1 = (cutI == 0 ? Integer.MIN_VALUE : nums1[cutI - 1]);
            //nums1数组分割后后部分的最小值
            int nums_i = (cutI == len1) ? Integer.MAX_VALUE : nums1[cutI];
            //nums2数组分割后前部分的最大值
            int nums_jm1 = (cutJ == 0 ? Integer.MIN_VALUE : nums2[cutJ - 1]);
            //nums2数组分割后后部分的最小值
            int nums_j = (cutJ == len2) ? Integer.MAX_VALUE : nums2[cutJ];
            if(Math.max(nums_im1, nums_jm1) <= Math.min(nums_i, nums_j)){
                leftMedium = Math.max(nums_im1, nums_jm1);
                rightMedium = Math.min(nums_i, nums_j);
                break;
            }else {
                cutI++;
            }
        }
        return (len1 + len2) % 2 == 0 ? (leftMedium + rightMedium) / 2.0 : leftMedium;

    }
```

另外我们可以对 i 在 [0,m] 的区间上进行二分搜索，找到最大的满足 A[i−1]≤B[j] 的 ii值，就得到了划分的方法。此时，划分前一部分元素中的最大值，以及划分后一部分元素中的最小值，才可能作为就是这两个数组的中位数

```java
public double findMedianSortedArrays3(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        int leftMedium = 0;
        int rightMedium = 0;
        int left = 0;
        int right = len1 - 1;
        //int leftLen = cutI + 1 + cutJ + 1; int rightLen = len1 + len2 - leftLen
        // 二者要相等，即可得等式cutI + cutJ = (len1 + len2) / 2
        //枚举cutI的值，根据cutI的值来确定cutJ的值，以满足前部分数组的最大值小于等于后部分数组的最小值
        while(left <= right){
            int cutI = (left + right) / 2;
            int cutJ = (len1 + len2 + 1) / 2 - cutI; //前半部分多一个元素
            //nums1数组分割后前部分的最大值
            int nums_im1 = (cutI == 0 ? Integer.MIN_VALUE : nums1[cutI - 1]);
            //nums1数组分割后后部分的最小值
            int nums_i = (cutI == len1) ? Integer.MAX_VALUE : nums1[cutI];
            //nums2数组分割后前部分的最大值
            int nums_jm1 = (cutJ == 0 ? Integer.MIN_VALUE : nums2[cutJ - 1]);
            //nums2数组分割后后部分的最小值
            int nums_j = (cutJ == len2) ? Integer.MAX_VALUE : nums2[cutJ];
            //如果nums1的前部分最大值比nums2的后部分最小值还小，说明cutI还可以尝试往后移动切分
            if(nums_im1 <= nums_j){
                leftMedium = Math.max(nums_im1, nums_jm1);
                rightMedium = Math.min(nums_i, nums_j);
                left = cutI + 1;
            }else {
                right = cutI - 1;
            }
        }
        return (len1 + len2) % 2 == 0 ? (leftMedium + rightMedium) / 2.0 : leftMedium;

    }
```

#### 4、最长连续序列

> 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
>
>  进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？
>
> 示例 1：输入：nums = [100,4,200,1,3,2]
> 输出：4
> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
> 示例 2：输入：nums = [0,3,7,2,5,8,4,6,0,1]
> 输出：9

###### 双指针（自己）

自己思路，先排序，然后遍历数组用双指针统计长度。但是当前时间复杂度不符合O(n)要求。

```java
public int longestConsecutive(int[] nums) {
        if(nums.length <= 1){
            return nums.length;
        }
        Arrays.sort(nums);
        int repeat = 0; //重复次数
        int index = 0; //子序列的头元素
        int result = 1; 
        int i = 1;
        for (; i < nums.length; i++) {
            if(nums[i] == nums[i-1]){
                repeat++;//相等的只记录重复次数
                continue;
            }
            if(nums[i] - nums[i-1] == 1){
                continue;//差1的继续迭代
            }else {//否则进行记录当前最长的子序列，并重置index指针，归零重复值
                result = Math.max(result, i - index - repeat);
                index = i;
                repeat = 0;
            }
        }
        return Math.max(result, i - index - repeat); //此处注意，否则会遗漏
    }
```



###### 哈希表法

遍历数组，将每个元素存入HashSet中。然后二次遍历数组，如果该值的下一个值存在则累加次数，直到下一个值不存在为止。**关键是如果某值的上一个值存在，则无需处理该值，因为遍历到上一个值的时候会一起处理从而避免了重复处理。**

```java
public int longestConsecutive2(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            set.add(nums[i]);
        }
        int result = 1;
        for (int i = 0; i < nums.length; i++) {
            int current = nums[i];
            int currentLen = 1;
            if(set.contains(current-1)){//上一个值存在，则跳过
                continue;
            }
            int temp = current;
            while(set.contains(++temp)){//下一个值存在则累加
                currentLen++;
            }
            result = Math.max(result, currentLen);
        }
        return result;
    }
```



#### 5、两数之和

> 

#### 6、三数之和

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。
>
> **示例 ：**
>
> ```
> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2],[-1,0,1]]
> ```

解法：循环，然后左右夹逼法，需要注意剔除重复的组合。**由此也可以发散到求k个元素和为target的算法：即使用k-2次循环，然后最后两个元素进行左右夹逼**

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    if(nums.length <= 2){
        return result;
    }
    int len = nums.length;
    Arrays.sort(nums);//排序成为有序数组
    for(int i = 0; i < nums.length - 2; i++){
        if(i > 0 && nums[i] == nums[i-1]){
            continue;//如果跟前一个i值相等，则说明遍历过组合，剔除掉
        }
        int j = i+1;//左边的遍历指针
        int k = len-1;//右边的遍历指针
        while(j < k){//开始夹逼
            int valueJ = nums[j];
            int valueK = nums[k];
            int des = nums[i]+nums[j]+nums[k];
            if(des == 0){
                result.add(Arrays.asList(nums[i], nums[j], nums[k]));
                //剔除重复，找到下一个不同的j和k
                while(j < len-1 && valueJ == nums[++j]);
                while(k > 0 && valueK == nums[--k]);
            }else if(des > 0){
                while(k > 0 && valueK == nums[--k]);//找到下一个不同的值对应的k
            }else{
                while(j < len-1 && valueJ == nums[++j]);//找到下一个不同的值对应的j
            }
        }
        return result;
    }
    
｝
```

#### 7、最接近的三数之和

> 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
>
> 示例：
>
> 输入：nums = [-1,2,1,-4], target = 1
> 输出：2
> 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

与上题解法一致。

```java
public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int len = nums.length;
        int result = Integer.MAX_VALUE;
        for (int i = 0; i < len - 2; i++) {
            if(i > 0 && nums[i] == nums[i-1]){
                continue;
            }
            int j = i + 1;
            int k = len - 1;
            while(j < k){
                int valueJ = nums[j];
                int valueK = nums[k];
                int sum = nums[i] + nums[j] + nums[k];
                if(result == Integer.MAX_VALUE || Math.abs(sum-target) < Math.abs(result-target)){
                    result = sum;
                }
                if(sum == target){
                    break;
                }else if(sum < target){
                    while(j < len - 1 && valueJ == nums[++j]);
                }else {
                    while(k > 0 && valueK == nums[--k]);
                }
            }
        }
        return result;
    }
```

#### 8、四数之和

> 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
>
> 注意：答案中不可以包含重复的四元组。
>

与三数之和解法一致，但要考虑去重的区别。

```java
public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        if(nums.length <= 3){
            return result;
        }
        int len = nums.length;
        Arrays.sort(nums);//排序
        for (int i = 0; i < len -3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {//第一个数如果重复选取则跳过
                continue;
            }
            //当前第一个数选择后，如果最小的组合都大于target，则后续的没有满足条件的了，无需选择了
            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
                break;
            }
            //当前第一个数选择后，如果最大的组合都小于target，则不用以第一个数为基础了，跳过
            if (nums[i] + nums[len - 3] + nums[len - 2] + nums[len - 1] < target) {
                continue;
            }
            for (int j = i+1; j < len-2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {//去重复
                    continue;
                }
                //优化判断
                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {
                    break;
                }
                //优化判断
                if (nums[i] + nums[j] + nums[len - 2] + nums[len - 1] < target) {
                    continue;
                }
                int m = j + 1;
                int k = len - 1;
                while(m < k){
                    int valueM = nums[m];
                    int valueK = nums[k];
                    int cur = nums[i] + nums[j] + nums[m] + nums[k];
                    if(cur == target){
                        result.add(Arrays.asList(nums[i], nums[j], nums[m], nums[k]));
                        while(m < len - 1 && valueM == nums[++m]);
                        while(k > 0 && valueK == nums[--k]);
                    }else if(cur < target){
                        while(m < len - 1 && valueM == nums[++m]);
                    }else {
                        while(k > 0 && valueK == nums[--k]);
                    }
                }
            }
        }
        return result;
    }
```

#### 9.移除数组元素

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>

题解：不使用额外的空间，即在原数组上进行操作。可使用一个index指针记录符合条件的元素位置，在遍历过程中不断更新index值。也是双指针的运用！

```java
public int removeElement(int[] nums, int val){
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] != val){
                nums[index++] = nums[i];
            }
        }
        return index;
    }
```

类似的反转链表：只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。

```java
public ListNode reverseNode(ListNode node){
    if(node == null || node.next == null){return node;}
    ListNode pre = null;
    ListNode cur = node;
    ListNode temp = null;
    while(cur != null){//细细体会
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
     
    }
}
```

#### 10.获取数组的下一个序列

> 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须 原地 修改，只允许使用额外常数空间。
>
> ```
> 输入：nums = [1,2,3]
> 输出：[1,3,2]
> ```

即获取下一个更大的数字。主要是在理解过程（即如何得到下一个排列数）：

- 首先从右边开始遍历，直到找到一个元素nums[i]<nums[i+1]，即得到一个较小值
- 然后在剩余的右边区间[i+1, len)区间从右边开始遍历，找到第一个nums[j]>nums[i]即较大值
- 交换nums[i]和nums[j]，然后对区间[i+1, len]进行升序排列，由分析可知该区间原始顺序为降序排列，即只需使用双指针算法反转该区间即可。

```java
public void getPermutation(int[] nums){
    if(nums.length <= 1){
        return;
    }
    int len = nums.length;
    int  i = len - 2;
    while(i >= 0 && nums[i] >= nums[i+1]){
        i--;
    }
    if(i != -1){
        int j = len - 1;
        while(j >= i+1 && nums[j] <= nums[i]){
            j--;
        }
        swap(nums, i, j);
    }
    reverse(nums, left, right);
}

public void reverse(int[] nums, int left, int right){
    while(left < right){
        swap(nums, left, right);
        left++;
        right--;
    }
}
public void swap(int[] nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = nums[i];
}
```

升级变种（第k个排列）：

> 给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
>
> "123"
> "132"
> "213"
> "231"
> "312"
> "321"
> 给定 n 和 k，返回第 k 个排列。
>
>  示例 1：
>
> 输入：n = 3, k = 3
> 输出："213"

题解：只需要套用上面求下一个排列的方法，循环k次即可。进阶的做法是利用`康托展开和逆康托展开`的方法。康托展开公式主要表示的就是在n个不同元素的全排列中, 比当前排列组合小的个数，那么也可以表示当前排列组合在n个不同元素的全排列中的名次。而逆康托展开主要用于根据排列的名次得到具体的排列数。只需要记住**排列数有个康托排列公式即可**。



类似问题：

> 给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。
>
> 请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。
>
> nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。
>
>  示例 1:
>
> 输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
> 输出: [-1,3,-1]

题解：可以通过**栈的单调性**来实现。即遍历nums1数组，利用栈的特性，如果当前入栈元素大于栈顶元素则栈顶元素出栈并记录栈顶元素的下一个最大值为当前入栈元素，直到栈为空或栈顶元素大于入栈元素。

```java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> result = new HashMap<>(nums2.length);
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < nums1.length; i++) {
            while(!stack.isEmpty() && stack.peekLast() < nums1[i]){
                result.put(stack.removeLast(), nums1[i]);
            }
            stack.offerLast(nums1[i]);
        }
        int[] res = new int[nums2.length];
        for (int i = 0; i < nums2.length; i++) {
            res[i] = result.getOrDefault(nums2[i], -1);
        }
        return res;
    }
```

变种：

> 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

```java
public int[] nextGreaterElements(int[] nums) {
        int[] result = new int[nums.length];
        Arrays.fill(result, -1);
        Deque<Integer> stack = new ArrayDeque();
        int len = nums.length;
        for (int i = 0; i < len * 2 - 1; i++) {
            while(!stack.isEmpty() && nums[stack.peekLast()] < nums[i%len]){
                result[stack.removeLast()] = nums[i%len];
            }
            stack.addLast(i % len);
        }
        return result;
    }
```

##### 知识储备：单调栈

从栈底元素到栈顶元素呈单调递增或单调递减，栈内序列满足单调性的栈。单调栈主要运用在给你一个数组序列，在遍历数组时，需要向前查看元素的这种情况，此时将前面的元素入栈，形成单调栈。具体再结合题目的用意，加以利用。

经典示例：

- 数组的下一个排列（如上题）
- 柱状图中最大的矩形

> ```text
> 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
> 求在该柱状图中，能够勾勒出来的矩形的最大面积。
> 以下是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。
> 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。
> 示例:
> 输入: [2,1,5,6,2,3]
> 输出: 10
> ```

![](https://pic3.zhimg.com/80/v2-74bf2c76493db23868fbbc587c916556_720w.jpg)

按照单调栈的思路，递增时入栈，其余时计算面积并出栈，直到继续递增时入栈。面积将通过计算当前位置和栈顶元素所在位置的宽度查，再乘上元素的height值的思路来做这题，具体过程：

- 遍历数组元素，当待入栈元素a[i]大于栈顶元素a[n]时，直接入栈；
- 当待入栈元素a[i]不大于栈顶元素a[n]时，此时计算元素a[n]所参与构成的最大矩形面积；
  - 栈中元素a[n]如果存在前一个元素a[m]即不为栈底元素,则说明a[n]在区间(m, i-1]中最小的，即a[n]能构成最大面积为a[n]*(i-1-m)，计算完成后a[n]出栈，继续循环判断*
  - *栈中元素a[n]如果是栈底元素，同理说明a[n]在区间[0, i-1]即(-1, i-1]中最小的，能构成的最大面积为a[n]*(i-1-(-1))，计算完成后a[n]出栈，继续循环判断
- 为了遍历结束后能计算所有元素的各自构成的最大面积，即可以在数组元素全部入栈后，再入栈一个Integer.MIN_VALUE已确保所有元素都进行计算然后出栈。

```java
public int largestRectangleArea(int[] heights) {
        //定义队列，作为栈使用
        Deque<Integer> stack = new ArrayDeque();
        //最大矩形面积
        int area = 0;
        for (int i = 0; i < heights.length; i++) {
            //对各元素进行判断，如果栈顶元素不小于当前待入栈元素，则计算栈顶元素所构成的最大面积然后出栈，知道栈顶元素小于当前元素或者栈为空时，对当前元素进行入栈
            while(!stack.isEmpty() && heights[stack.peek()] >= heights[i]){
                area = Math.max(area, getCurrentArea(stack, heights, i));
            }
            stack.push(i);
        }
        //数组元素全部入栈后，再将最小整数进行同样的入栈逻辑，以计算栈中所有元素各自所构成的最大面积
        while (!stack.isEmpty() && heights[stack.peek()] >= Integer.MIN_VALUE){
            area = Math.max(area, getCurrentArea(stack, heights, heights.length));
        }
        return area;
    }

    /**
    *获取当前栈顶元素所构成的最大面积，由上分析知公式为：a[n] * (i-1 -m)
    */
    public int getCurrentArea(Deque<Integer> stack, int[] nums, int index){
        Integer start = stack.pop();
        return nums[start] * (index -1 - (stack.isEmpty() ? -1 : stack.peek()));
    }
```

知识储备：队列

顶层**接口**Queue，继承了Collection接口。主要声明了6个基础方法`add、offer、remove、poll、element、peek`。Queue其拥有三个直接接口子类：

- AbstactQueue

  AbstactQueue继承自Queue，其主要重写了add、remove、element方法。重写也很简单，就是内部分别调用offer、poll、peek方法，若元素不存在则抛出异常。其下属部分常见的具体实现类大部分均为继承自AbstractQueue，实现BlockingQueue接口。

- BlockingQueue

其主要新增定义了take和put方法，由其实现可知二者为阻塞方法。常见阻塞队列实现类：ArrayBlockingQueue、SynchronousQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue、BlockingDeque（双向阻塞队列）

BlockingQueue的操作可以分为下面四类：

| 操作类型 | Throws exception | Special value | Blocks         | Times out            |
| -------- | ---------------- | ------------- | -------------- | -------------------- |
| Insert   | add(e)           | offer(e)      | put(e)         | offer(e, time, unit) |
| Remove   | remove()         | poll()        | take()         | poll(time, unit)     |
| Examine  | element()        | peek()        | not applicable | not applicable       |

第一类是会抛出异常的操作，当遇到插入失败，队列为空的时候抛出异常。

第二类是不会抛出异常的操作。

第三类是会Block的操作。当Queue为空或者达到最大容量的时候。

第四类是time out的操作，在给定的时间里会Block，超时会直接返回。



- Deque

  双端队列，继承自Queue。在原有的基础上定义了xxxFirst和xxxLast方法，并且新定义了针对栈场景的push和pop方法。其常见的实现类有BlockingDeque、LinkedList。

  同样的，我们也可以将Deque的方法用下面的表格来表示，Deque的方法可以分为对头部的操作和对尾部的操作：

  | 方法类型 | Throws exception | Special value | Throws exception | Special value |
  | -------- | ---------------- | ------------- | ---------------- | ------------- |
  | Insert   | addFirst(e)      | offerFirst(e) | addLast(e)       | offerLast(e)  |
  | Remove   | removeFirst()    | pollFirst()   | removeLast()     | pollLast()    |
  | Examine  | getFirst()       | peekFirst()   | getLast()        | peekLast()    |
  和Queue的方法描述基本一致，这里就不多讲了。

  **当Deque以 FIFO (First-In-First-Out)的方法处理元素的时候，Deque就相当于一个Queue。**

  **当Deque以LIFO (Last-In-First-Out)的方式处理元素的时候，Deque就相当于一个Stack**。

  ArrayDeque类中，add/offer、remove/poll方法是针对队列的使用，即实际为addLast/offerLast和removeFirst/pollFisrt。而push和pop是针对栈的使用，实际为addFirst和removeFirst。peek方法都是peekFirst。 即使用ArrayDeque作为栈应用的话，可以使用push、pop、peek的组合！

  

  另外TransferQueue继承自BlockingQueue，为什么叫Transfer呢？因为TransferQueue提供了一个transfer的方法，生产者可以调用这个transfer方法，从而等待消费者调用take或者poll方法从Queue中拿取数据。

  还提供了非阻塞和timeout版本的tryTransfer方法以供使用。

  我们举个TransferQueue实现的生产者消费者的问题。

- ConcurrentLinkedQueue

 并发队列，通过CAS控制。



Stack类。继承自Vector类（线程安全的）。



#### 11.接雨水

> 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>
>  ![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)
>
> 示例 1：
>
> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出：6
> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
> 示例 2：
>
> 输入：height = [4,2,0,3,2,5]
> 输出：9

一样使用单调栈，当递减时入栈，当前入栈元素大于栈顶元素时则开始计算夹缝面积，计算完后如果栈顶元素大于当前待入栈元素则栈顶出栈，否则当前元素入栈（即当前元素所形成的夹缝计算已结束）。

```java
public int trap(int[] height) {
    	//存储下标和值
        Stack<Map.Entry<Integer, Integer>> stack = new Stack<>();
        int area = 0;
        for (int i = 0; i < height.length; i++) {
            int cur = height[i];
            int bottom = 0; //bottom表示当前应扣除的底部高度，凹陷处迭代    
            while(!stack.isEmpty() ){
                Map.Entry<Integer, Integer> top = stack.peek();//栈顶元素
                //先计算面积，如果是递减的或挨着的，面积计算为0
                area += (i - 1 - top.getKey()) * (Math.min(top.getValue(), cur) - bottom);
                bottom = stack.peek().getValue();
                if(top.getValue() > cur){
                    break;//递减入栈
                }else {
                    stack.pop();//递增时迭代计算形成的凹陷
                }
            }
            Map<Integer, Integer> map = new HashMap<>();
            map.put(i, cur);
            stack.push(map.entrySet().iterator().next());
        }
        return area;
        
    }
```

#### 12.旋转图像

> 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
>
> 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
>
> ![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)
>
> ```
> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[[7,4,1],[8,5,2],[9,6,3]]
> ```

题解一：

分析得到旋转的关键等式：

```java
matrix_new[j][n - i - 1] = matrix[i][j];
```

然后交换。

题解二：

顺时针旋转  等价于 先 水平轴翻转，然后主对角线翻转。

