#### 贪心算法

1、分糖果

```java
/**
     * 贪心分糖果问题，尽量用最小的糖果满足该孩子
     * @param child 孩子数组
     * @param candy 糖果数组
     * @return
     */
    public int divideCandy(int[] child, int[] candy){
        Arrays.sort(child);
        Arrays.sort(candy);
        int childIndex = 0;
        int candyIndex = 0;
        while(childIndex < child.length && candyIndex < candy.length){
            if(candy[candyIndex] >= child[childIndex]){
                //能满足，继续匹配下一个
                childIndex++;
            }
            //不管满足与否，用下一个糖果匹配
            candyIndex++;
        }
        return childIndex;
    }
```

2、摇摆序列

```java
private Integer BEGIN = 0;
private Integer UP = 1;
private Integer DOWN = 2;
//状态机分析，节点遍历前对于结果序列都只有三种状态：初始状态、上升状态、下降状态。根据不同的状态与当前节点与前一个节点的大小作出状态变换
public int getSwingLen(int[] arr){
        if(arr.length == 2){
            return arr.length;
        }
        int state = BEGIN;
        int result = 1;
        for (int i = 1; i < arr.length; i++) {
            switch (state){
                case 0:
                    if(arr[i] > arr[i-1]){
                        state = UP;
                        result++;
                    }
                    if(arr[i] < arr[i-1]){
                        state = DOWN;
                        result++;
                    }
                    break;
                case 1:
                    if(arr[i] < arr[i-1]){
                        state = DOWN;
                        result++;
                    }
                    break;
                case 2:
                    if(arr[i] > arr[i-1]){
                        state = UP;
                        result++;
                    }
                    break;
                default:
                    break;
            }
        }
        return result;
    }
```

3、数组跳跃游戏-A

```java
//只是求解是否可以从头跳到尾部，而不用关注如何跳。jump从0位置开始跳，最远跳arr[0]位置A,在遍历0-A位置中，如果发现可以跳到比A更远的位置时，则更新最远位置（若没有发现比A更远的位置，则循环条件限制最多只能跳到A）。循环结束后，jump如果在数组尾部，则表示能跳完，否则不能。
public Boolean jumpGame(int[] arr) {
        int[] mostFarIndex = new int[arr.length];
        //初始化distance数组，记录最远可跳至的位置
        for (int i = 0; i < arr.length; i++) {
            mostFarIndex[i] = i + arr[i];
        }
        //jump 表示当前位置
        int jump = 0;
        //maxIndex表示从当前jump可以到达的最远位置
        int maxIndex = mostFarIndex[0];

        while(jump < arr.length && jump <= maxIndex){
            //如果当前可以跳的更远，则更新maxIndex
            if(maxIndex < mostFarIndex[jump]){
                maxIndex = mostFarIndex[jump];
            }
            //扫描jump
            jump++;
        }
        //如果jump到达尾部，则返回true
        if(jump == arr.length){
            return true;
        }
        return false;
    }
```

4、跳跃游戏B（最少跳几步）

```java
/**
     * 求从数组头到尾最少跳几次：
     jump最开始从0位置开始跳，最远跳arr[0]位置A,在遍历0-A位置中，如果发现可以跳到比A更远的位置时，则记录下更远位置。直到遍历到A位置后，此时必须要跳一步（不管是从0跳到0-A之间的哪个位置，反正要跳一步），跳一步后更新当前可跳到更远的位置（之前遍历中记录的preMaxIndex）
     
     * @param arr
     * @return
     */
    public static int jumpMinStep(int[] arr){
        if(arr.length < 2){
            return 0;
        }
        //当前位置可以跳到最远位置的index
        int currentMaxIndex = arr[0];
        //遍历各个位置过程中，可以达到的最远位置
        int preMaxIndex = arr[0];
        int jumpMin = 1;
        int tempOldIndex = 0;
        int tempNewIndex = 0;
        for (int i = 0; i < arr.length; i++) {
            //若无法再向前移动了，才进行跳跃。并更新当前可达到的最远位置
            if(i > currentMaxIndex){
                //达到阈值，则表示逼不得已必须得跳一步了
                jumpMin++;
                System.out.println("从第"+tempOldIndex+"位置跳到第"+tempNewIndex+"位置");
                tempOldIndex = tempNewIndex;
                currentMaxIndex = preMaxIndex;//重点
            }
            if(preMaxIndex < arr[i] + i){
                tempNewIndex = i;
                preMaxIndex = arr[i] +  i;
            }
        }
        System.out.println("从第"+tempOldIndex+"位置跳到第"+(arr.length-1)+"位置");
        return jumpMin;
    }
```

5、射击气球游戏（452）

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。

```java
//先将气球按左端点排序，然后以第一个气球区间为当前射击区间，依次遍历后面的气球，然后根据重叠区域更新射击区间。当新气球的区间不能被射击区间覆盖时，则重新指定为射击区间，并增加弓箭。
public static int findMinArrowShots(int[][] points) {
        if(points.length <= 1){
            return points.length;
        }
    	//按左端点排序
        Arrays.sort(points, new Comparator<int[]>() {
            public int compare(int[] point1, int[] point2) {
                if (point1[1] > point2[1]) {
                    return 1;
                } else if (point1[1] < point2[1]) {
                    return -1;
                } else {
                    return 0;
                }
            }
        });
        int[] cur = points[0]; //cur表示当前射击区间
        int arrows = 1; //表示所用弓箭数
        for (int i = 1; i < points.length;) {
            int[] next = points[i];
            if(next[0] <= cur[1]){ //新气球区间跟射击区间有重叠部分
                i++;//则更新射击区间后遍历下一个气球
                cur[0] = next[0];
                cur[1] = Math.min(cur[1], next[1]);
            }else {//没有重叠部分，则新增弓箭，并重置射击区间
                arrows++;
                cur = next;
            }
        }
        return arrows;
    }
```

6、最优加油问题

![](E:\study\再出发\算法示例\image\tanxin6.jpg)

#### 回溯算法

1、求数组（无重复元素）所有不重复子集

leetcode78题目描述：

给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。

![](E:\study\再出发\算法示例\image\huisu1-2.jpg)

解法一：

```java
/**   画出递归树尤其重要！！！通过每个元素选择和不选择就可以组成一个二叉树
     * DFS优势：用固定的变量遍历整个选择空间
     * @param i 对第几个元素进行选择
     * @param nums 原始数组
     * @param item 选择过程中的path（即各个节点）
     * @param result 最终结果
     */
    public void helper(int i, int[] nums, List<Integer> item, List<List<Integer>> result){
        if(i >= nums.length){
            //DFS当达到叶子节点后则记录最终选择方案
            result.add(new ArrayList<>(item));
            return;
        }
        //不选择当前元素，直接进入下一个元素
        helper(i+1, nums, item, result);
        //选择当前元素后进入下一层
        item.add(nums[i]);
        helper(i+1, nums, item, result);
        //撤销已做选择
        item.remove((Object)nums[i]);
    }
```

解法二：回溯

```java
/**
     * 典型的回溯：循环递归
     * @param begin 开始下标
     * @param nums 
     * @param item
     * @param result
     */
    public static void helper2(int begin, int[] nums, List<Integer> item, List<List<Integer>> result){
        result.add(new ArrayList<>(item));
        for (int j = begin; j < nums.length; j++) {
            //选择当前元素后进入下一层
            item.add(nums[j]);
            helper(j+1, nums, item, result);
            //撤销已做选择
            item.remove((Object)nums[j]);
        }
    }
```

解法三：利用&运算

```java
public static List<List<Integer>> helper(int[] nums){
        List<List<Integer>> result = new ArrayList<>();
        //全部子集，由于每个元素都有选或不选两种，故一共2的len次方个组合子集
        int subSets = 1 << nums.length;
        for (int i = 0; i < subSets; i++) {
            List<Integer> item = new ArrayList<>();
            //开始构建每个子集，nums的每个元素都当成二进制中的某一位，通过&来判断当前组合i是否包含有该元素
            for (int j = 0; j < nums.length; j++) {
                if((i & (1 << j)) > 0){
                    item.add(nums[j]);
                }
            }
            result.add(item);
        }
        return result;
    }
```

2、求数组（有重复元素）所有不重复子集

可以先排序再去重，转化为第一题求解。

3、组合数之和

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 

解：其实跟第一题并无大区别，只需要引入一个sum变量记录当前item集合中元素之和，然后进行递归剪纸（即判断当前和大于target时则不再继续往下递归）



求一个字符串不重复的子串

```java
public static int helper(String s){
        if(s == null || s.length() == 0){
            return 0;
        }
        Map<Character, Integer> params = new HashMap<>();
        int result = 0;
        int begin = 0;
        for (int i = 0; i < s.length(); i++) {
            if(params.containsKey(s.charAt(i))){
                //防止左指针倒退
                begin = Math.max(begin, params.get(s.charAt(i)) + 1);
            }
            params.put(s.charAt(i), i);
            result = Math.max(result, i - begin + 1);
        }
        return result;
    }
```

求一个字符串最大的回文子串

```java
public String helper1(String s){
        int len = s.length();
        boolean[][] status = new boolean[len][len];
        String result = "";
        for (int size = 0; size < len; size++) {
            //size表示字符串的长度
            for (int i = 0; i + size < len; i++) {
                int j = i + size;
                if(size == 0){
                    status[i][j] = true;
                }else if(size == 1){
                    status[i][j] = s.charAt(i) == s.charAt(j);
                }else {
                    status[i][j] = (s.charAt(i) == s.charAt(j) && status[i+1][j-1]);
                }
                //如果当前i-j为true，且长度大于result，则更新result
                if(status[i][j] && ((size + 1) > result.length())){
                    result = s.substring(i, i + size + 1);
                }
            }
        }
        return result;
    }
```

